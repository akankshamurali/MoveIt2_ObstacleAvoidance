#include <rclcpp/rclcpp.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>
#include <moveit/move_group_interface/move_group_interface.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>
#include <thread>  // ‚Üê add thisint main(int argc, char** argv)
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared("panda_plan_around_box");
  rclcpp::executors::SingleThreadedExecutor exec;
  exec.add_node(node);

  // Allow MoveIt to spin ROS for action/result topics
  auto spinner = std::make_shared<std::thread>([&exec]() { exec.spin(); });

  // 1) Connect to Panda arm
  static const std::string PLANNING_GROUP = "panda_arm";
  moveit::planning_interface::MoveGroupInterface move_group(node, PLANNING_GROUP);
  moveit::planning_interface::PlanningSceneInterface planning_scene_interface;

  // Helpful timeouts
  move_group.setPlanningTime(10.0);
  move_group.setMaxVelocityScalingFactor(0.5);
  move_group.setMaxAccelerationScalingFactor(0.5);

  // 2) Add a box between robot and goal (in world frame)
  moveit_msgs::msg::CollisionObject box;
  box.header.frame_id = move_group.getPlanningFrame(); // usually "world"
  box.id = "box1";

  shape_msgs::msg::SolidPrimitive primitive;
  primitive.type = primitive.BOX;
  primitive.dimensions = {0.20, 0.20, 0.20}; // 20cm cube

  geometry_msgs::msg::Pose box_pose;
  box_pose.orientation.w = 1.0;
  box_pose.position.x = 0.50;
  box_pose.position.y = 0.00;
  box_pose.position.z = 0.30;

  box.primitives.push_back(primitive);
  box.primitive_poses.push_back(box_pose);
  box.operation = box.ADD;

  planning_scene_interface.applyCollisionObjects({box});

  // Give the scene a moment to update
  rclcpp::sleep_for(std::chrono::milliseconds(500));

  // 3) Define a pose goal that requires going around the box
  geometry_msgs::msg::Pose target;
  target.orientation.w = 1.0;   // simple orientation
  target.position.x = 0.70;     // a bit behind the box along +x
  target.position.y = 0.20;     // offset in y so straight-line collides
  target.position.z = 0.40;

  move_group.setPoseTarget(target, "panda_hand"); // end-effector link is fine

  // 4) Plan
  moveit::planning_interface::MoveGroupInterface::Plan plan;
  bool success = (move_group.plan(plan) == moveit::core::MoveItErrorCode::SUCCESS);

  RCLCPP_INFO(node->get_logger(), "[Plan] %s", success ? "SUCCESS" : "FAILED");

  if (success)
  {
    // 5) Execute
    auto exec_result = move_group.execute(plan);
    RCLCPP_INFO(node->get_logger(), "[Execute] %s",
                (exec_result == moveit::core::MoveItErrorCode::SUCCESS) ? "SUCCESS" : "FAILED");
  }

  // Keep box visible for a moment
  rclcpp::sleep_for(std::chrono::seconds(2));

  // planning_scene_interface.removeCollisionObjects({"box1"});

  exec.cancel();
  spinner->join();
  rclcpp::shutdown();
  return 0;
}

